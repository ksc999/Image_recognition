# 图像处理大作业

## 基础知识练习题

### 2

- 画出一个圆：

```matlab
% No.1
I = load('hall.mat');
I = I.hall_color;
imshow(I);
% 使用images.roi.Circle作圆
h = images.roi.Circle(gca,'Center',[84,60],'Radius',60, 'Color', 'r', 'FaceAlpha', 0, 'InteractionsAllowed', 'none');
```

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210630154533059.png" alt="image-20210630154533059" style="zoom: 50%;" />

- 使用mask: 在images能够使用的函数里大约找了两个小时，也没有找到一个合适的函数来直接生成与像素位置有关的mask，因此只能手写for循环实现：

```matlab
% No.2
for a = 1: 3
    for b = 1: 120
        for c = 1: 168
            if mod(b+c, 2) == 0
                I(b, c, a) = 0;
            end
        end
    end
end
imshow(I);
```

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210630162944527.png" alt="image-20210630162944527" style="zoom:50%;" />

## 图像压缩编码练习题

### 1

不能，理由如下：

```matlab
choosed_block = I(1: 8, 1: 8);
% do dct2 first, then sub 128
tmp_1_1 = dct2(choosed_block) - 128;
% do sub 128 first, then do dct2
tmp_1_2 = dct2(choosed_block - 128);
figure(1);
subplot(1,2,1);
imshow(tmp_1_1);
title('do dct2 first, then sub 128');
set(gca, 'FontSize', 12);
subplot(1,2,2);
imshow(tmp_1_2);
title('do sub 128 first, then do dct2');
set(gca, 'FontSize', 12);
```

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_1.bmp" style="zoom:67%;" />

很明显，两者的结果不一样。

### 2

自定义dct2函数：

```matlab
function C = my_dct2(P)
    P = double(P - 128);    % minus the DC component, and convert uint8 to double
    tmp = size(P);
    N = tmp(1);             % get size of the input block
    D = zeros(N);  
    
    % compute matrix D
    D(1, :) = sqrt(1/2);
    for a = 2: N
        for b = 1: N
            D(a, b) = cos((a-1)* (2*b-1)* pi/ (2*N));
        end
    end
    D = D * sqrt(2/ N);
    disp(D);

    % compute C
    C = D* P* D';
end
```

在jpeg.m中调用my_dct2并作图验证：

```matlab
choosed_block = I(1: 8, 1: 8);
D_by_matlab_dct2 = dct2(choosed_block - 128);
D_my_dct2 = my_dct2(choosed_block);
figure(2);
subplot(1,2,1);
imshow(D_by_matlab_dct2);
title('matlab-dct2');
set(gca, 'FontSize', 12);
subplot(1,2,2);
imshow(D_my_dct2);
title('my-dct2');
set(gca, 'FontSize', 12);
```

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_2.bmp" style="zoom: 67%;" />

由此可见，两者确实一样。

### 3

- 将后面的列置为0（为使得视觉效果明显，将列总数调大了许多）：

```matlab
t1 = 1;
t2 = 1;
N = 120;
choosed_block_3 = I((t1-1)*N+1: t1*N, (t2-1)*N+1: t2*N);
C = dct2(choosed_block_3 - 128);
% set the four right columns to zeros
C(: , round(N/2):N) = 0;
disp(C)
distorted_block_1 = idct2(C);
figure(3);
subplot(1,2,1);
imshow(choosed_block_3);
title('origin');
set(gca, 'FontSize', 12);
subplot(1,2,2);
imshow(distorted_block_1);
title('distorted');
set(gca, 'FontSize', 12);
```

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_3_1.bmp" style="zoom:67%;" />

- 将前面的列置为0：

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_3_2.bmp" style="zoom:67%;" />

由此可见，将列消除的效果都会使得图像在纵向更加光滑，而消除前面的列明显影响更大。

### 4

```matlab
t1 = 1;
t2 = 1;
N1= 120;
N2 = 160;
choosed_block_4 = I((t1-1)*N1+1: t1*N1, (t2-1)*N2+1: t2*N2);
C_origin = dct2(choosed_block_4 - 128);
figure(4);   % origin
subplot(2,2,1);
imshow(choosed_block_4);
title('origin');
set(gca, 'FontSize', 12);
C_transpose = C_origin'; % transpose
block_transpose = idct2(C_transpose);
subplot(2,2,2);
imshow(block_transpose);
title('transpose');
set(gca, 'FontSize', 12);
C_rotate_90 = rot90(C_origin, 1);   % rotate 90
block_rotate_90 = idct(C_rotate_90);
subplot(2,2,3);
imshow(block_rotate_90);
title('rotate 90');
set(gca, 'FontSize', 12);
C_rotate_180 = rot90(C_origin, 2);   % rotate 180
block_rotate_180 = idct(C_rotate_180);
subplot(2,2,4);
imshow(block_rotate_180);
title('rotate 180');
set(gca, 'FontSize', 12);
```

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_4.bmp" style="zoom:80%;" />

由此可见，旋转之后，由于直流分量的位置发生了改变，直接导致了图像中充满了噪声。但是在转置时，直流分量的位置仍然固定，因此图像依然较为清晰。

### 5

DC分量的差分可以等效为以下离散系统：
$$
s(n)=e(n-1)-e(n)
$$
则利用$freqz$ 函数，可以得到其DTFT幅频特性曲线：

```matlab
a = 1;
b = [-1, 1];
figure(5);
freqz(b, a, 200);
```

<img src="E:\courses\matlab\图像处理大作业\image\jpge_5.bmp" style="zoom:67%;" />

由此可见，其为高通系统。

现进行差分，其实是一种去冗余的操作。因此DC分量中的直流频率分量更多。如此一来，先进行差分，可以使得DC范围大幅下降（编码长度减小），而精度不受损失。

### 6

由DC表可得，预测误差的二进制位数对应着$Categery$的值。

### 7

有两种方法：

- 使用for循环，得到zig-zag编码
- 使用数组索引，对原矩阵元素进行展开重排

在matlab中，应尽可能少的使用for循环，而matlab的数组有自带index索引功能，故选用后者进行设计：

```matlab
function Z = zig_zag_code(A)
    storage_index = [
        1,...
        2,9,...
        17,10,3,...
        4,11,18,25,...
        33,26,19,12,5,...
        6,13,20,27,34,41,...
        49,42,35,28,21,14,7,...
        8,15,22,29,36,43,50,57,...
        58,51,44,37,30,23,16,...
        24,31,38,45,52,59,...
        60,53,46,39,32,...
        40,47,54,61,...
        62,55,48,...
        56,63,...
        64
    ];
    A = A';
    A = A(:);
    Z = A(storage_index);
end
```

十分高效。

