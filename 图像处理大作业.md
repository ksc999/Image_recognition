# 图像处理大作业

## 基础知识练习题

### 2

- 画出一个圆：

```matlab
% No.1
I = load('hall.mat');
I = I.hall_color;
imshow(I);
% 使用images.roi.Circle作圆
h = images.roi.Circle(gca,'Center',[84,60],'Radius',60, 'Color', 'r', 'FaceAlpha', 0, 'InteractionsAllowed', 'none');
```

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210630154533059.png" alt="image-20210630154533059" style="zoom: 50%;" />

- 使用mask: 在images能够使用的函数里大约找了两个小时，也没有找到一个合适的函数来直接生成与像素位置有关的mask，因此只能手写for循环实现：

```matlab
% No.2
for a = 1: 3
    for b = 1: 120
        for c = 1: 168
            if mod(b+c, 2) == 0
                I(b, c, a) = 0;
            end
        end
    end
end
imshow(I);
```

<img src="C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210630162944527.png" alt="image-20210630162944527" style="zoom:50%;" />

## 图像压缩编码练习题

### 1

不能，理由如下：

```matlab
choosed_block = I(1: 8, 1: 8);
% do dct2 first, then sub 128
tmp_1_1 = dct2(choosed_block) - 128;
% do sub 128 first, then do dct2
tmp_1_2 = dct2(choosed_block - 128);
figure(1);
subplot(1,2,1);
imshow(tmp_1_1);
title('do dct2 first, then sub 128');
set(gca, 'FontSize', 12);
subplot(1,2,2);
imshow(tmp_1_2);
title('do sub 128 first, then do dct2');
set(gca, 'FontSize', 12);
```

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_1.bmp" style="zoom:67%;" />

很明显，两者的结果不一样。

### 2

自定义dct2函数：

```matlab
function C = my_dct2(P)
    P = double(P - 128);    % minus the DC component, and convert uint8 to double
    tmp = size(P);
    N = tmp(1);             % get size of the input block
    D = zeros(N);  
    
    % compute matrix D
    D(1, :) = sqrt(1/2);
    for a = 2: N
        for b = 1: N
            D(a, b) = cos((a-1)* (2*b-1)* pi/ (2*N));
        end
    end
    D = D * sqrt(2/ N);
    disp(D);

    % compute C
    C = D* P* D';
end
```

在jpeg.m中调用my_dct2并作图验证：

```matlab
choosed_block = I(1: 8, 1: 8);
D_by_matlab_dct2 = dct2(choosed_block - 128);
D_my_dct2 = my_dct2(choosed_block);
figure(2);
subplot(1,2,1);
imshow(D_by_matlab_dct2);
title('matlab-dct2');
set(gca, 'FontSize', 12);
subplot(1,2,2);
imshow(D_my_dct2);
title('my-dct2');
set(gca, 'FontSize', 12);
```

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_2.bmp" style="zoom: 67%;" />

由此可见，两者确实一样。

### 3

- 将后面的列置为0（为使得视觉效果明显，将列总数调大了许多）：

```matlab
t1 = 1;
t2 = 1;
N = 120;
choosed_block_3 = I((t1-1)*N+1: t1*N, (t2-1)*N+1: t2*N);
C = dct2(choosed_block_3 - 128);
% set the four right columns to zeros
C(: , round(N/2):N) = 0;
disp(C)
distorted_block_1 = idct2(C);
figure(3);
subplot(1,2,1);
imshow(choosed_block_3);
title('origin');
set(gca, 'FontSize', 12);
subplot(1,2,2);
imshow(distorted_block_1);
title('distorted');
set(gca, 'FontSize', 12);
```

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_3_1.bmp" style="zoom:67%;" />

- 将前面的列置为0：

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_3_2.bmp" style="zoom:67%;" />

由此可见，将列消除的效果都会使得图像在纵向更加光滑，而消除前面的列明显影响更大。

### 4

```matlab
t1 = 1;
t2 = 1;
N1= 120;
N2 = 160;
choosed_block_4 = I((t1-1)*N1+1: t1*N1, (t2-1)*N2+1: t2*N2);
C_origin = dct2(choosed_block_4 - 128);
figure(4);   % origin
subplot(2,2,1);
imshow(choosed_block_4);
title('origin');
set(gca, 'FontSize', 12);
C_transpose = C_origin'; % transpose
block_transpose = idct2(C_transpose);
subplot(2,2,2);
imshow(block_transpose);
title('transpose');
set(gca, 'FontSize', 12);
C_rotate_90 = rot90(C_origin, 1);   % rotate 90
block_rotate_90 = idct(C_rotate_90);
subplot(2,2,3);
imshow(block_rotate_90);
title('rotate 90');
set(gca, 'FontSize', 12);
C_rotate_180 = rot90(C_origin, 2);   % rotate 180
block_rotate_180 = idct(C_rotate_180);
subplot(2,2,4);
imshow(block_rotate_180);
title('rotate 180');
set(gca, 'FontSize', 12);
```

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_4.bmp" style="zoom:80%;" />

由此可见，旋转之后，由于直流分量的位置发生了改变，直接导致了图像中充满了噪声。但是在转置时，直流分量的位置仍然固定，因此图像依然较为清晰。

### 5

DC分量的差分可以等效为以下离散系统：
$$
s(n)=e(n-1)-e(n)
$$
则利用$freqz$ 函数，可以得到其DTFT幅频特性曲线：

```matlab
a = 1;
b = [-1, 1];
figure(5);
freqz(b, a, 200);
```

<img src="E:\courses\matlab\图像处理大作业\image\jpge_5.bmp" style="zoom:67%;" />

由此可见，其为高通系统。

现进行差分，其实是一种去冗余的操作。因此DC分量中的直流频率分量更多。如此一来，先进行差分，可以使得DC范围大幅下降（编码长度减小），而精度不受损失。

### 6

由DC表可得，预测误差的二进制位数对应着$Categery$的值。

### 7

有两种方法：

- 使用for循环，得到zig-zag编码
- 使用数组索引，对原矩阵元素进行展开重排

在matlab中，应尽可能少的使用for循环，而matlab的数组有自带index索引功能，故选用后者进行设计：

```matlab
function Z = zig_zag_code(A)
    storage_index = [
        1,...
        2,9,...
        17,10,3,...
        4,11,18,25,...
        33,26,19,12,5,...
        6,13,20,27,34,41,...
        49,42,35,28,21,14,7,...
        8,15,22,29,36,43,50,57,...
        58,51,44,37,30,23,16,...
        24,31,38,45,52,59,...
        60,53,46,39,32,...
        40,47,54,61,...
        62,55,48,...
        56,63,...
        64
    ];
    A = A';
    A = A(:);
    Z = A(storage_index);
end
```

十分高效。

### 8

设计代码如下：

```matlab
function Z_q = quantify(I, Q)
    % get height and width of the input image
    s = size(I);
    H = s(1);
    W = s(2);
    N = 8;

    % tackle by blocks
    Z_q = zeros(N*N , H*W / (N*N));
    for a = 1 : N : (H/N - 1) * N + 1
        for b = 1 : N : (W/N - 1) * N + 1
            block_tmp = I(a : a+N-1 , b : b+N-1);
            block_tmp = double(block_tmp);
            block_tmp_C = dct2(block_tmp - 128);
            block_tmp_Q = round(block_tmp_C ./ Q);
            block_tmp_Z = zig_zag_code(block_tmp_Q);
            tmp = floor(a/N) * (W/N) + floor(b/N) + 1;
            Z_q(: , tmp) = block_tmp_Z;
        end
    end
end
```

将量化所得的$64\times315$矩阵显示出来：

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_8.bmp" style="zoom:150%;" />

由此可见，经过量化后，每一个区域的高频分量已经变为0（在图像中，黑色为0），为下文的熵编码做了准备工作。

### 9

- 编码DC部分：

```matlab
function DC_stream = DC_encode(Z_q_DC, DC)
    % create empty DC stream
    DC_stream = [];

    % do difference first
    DC_diff = -diff(Z_q_DC);
    DC_diff = [Z_q_DC(1), DC_diff];

    % do DC encode
    for k = 1 : length(DC_diff)
        tmp = DC_diff(k);
        % 0 situation must be considerd exclusively, 
        % for de2bi(0) also has length 1
        if tmp == 0 
             % tmp_Huffman = [0, 0];
             % tmp_binary = 0;
             DC_stream = [DC_stream, [0,0,0]];
             continue;
        end
        tmp_if_negative = (tmp < 0);
        tmp_binary = flip(de2bi(abs(tmp)));  % de2bi's input can only be non-negatve
        if tmp_if_negative
            tmp_binary = 1 - tmp_binary;    % 1-component of negative input
        end
        tmp_index = DC(length(tmp_binary) + 1, :);
        tmp_Huffman_length = tmp_index(1);
        tmp_Huffman = tmp_index(2: 1+tmp_Huffman_length);
        DC_stream = [DC_stream, tmp_Huffman, tmp_binary];
    end
end
```

- 编码AC部分：

```matlab
function AC_stream = AC_encode(Z_q_AC, AC)
    % create empty AC stream
    AC_stream = [];
    [~, W] = size(Z_q_AC);

    % outer loop gets every block's AC information
    for a = 1 : W
        block_AC = Z_q_AC(:, a);   
        block_non_zeros = [0; find(block_AC ~= 0)]; % find non-zeros of one block

        % inner loop computes AC_stream
        for b = 2 : length(block_non_zeros)

            % get run and number
            tmp = block_AC(block_non_zeros(b));
            count_zeros = block_non_zeros(b) - block_non_zeros(b-1) - 1;

            % tackle the situation when run >= 16
            while count_zeros >= 16
                AC_stream = [AC_stream, [1,1,1,1,1,1,1,1,0,0,1]];
                count_zeros = count_zeros - 16;
            end

            % get size
            tmp_if_negative = (tmp < 0);
            tmp_binary = flip(de2bi(abs(tmp)));  % de2bi's input can only be non-negatve
            if tmp_if_negative
                tmp_binary = 1 - tmp_binary;    % 1-component of negative input
            end
            tmp_length = length(tmp_binary);

            % get Huffman code
            tmp_index = AC(10 * count_zeros + tmp_length, :);
            tmp_Huffman_length = tmp_index(3);
            tmp_Huffman = tmp_index(4: 3 + tmp_Huffman_length);
            AC_stream = [AC_stream, tmp_Huffman, tmp_binary];
        end

        % add EOB to AC_stream
        AC_stream = [AC_stream, [1,0,1,0]];
    end
end
```

- 整体编码：

```matlab
function [DC_stream, AC_stream] = encode(Z_q, DC, AC)
    [H, ~] = size(Z_q);
    Z_q_DC = Z_q(1, :);
    Z_q_AC = Z_q(2:H, :);
    DC_stream = DC_encode(Z_q_DC, DC);
    AC_stream = AC_encode(Z_q_AC, AC);
end
```

- 保存数据至文件部分：

```matlab
[DC_stream, AC_stream] = encode(Z_q, DC, AC);
[I_H, I_W] = size(I);
save('jpegcodes.mat', 'I_H', 'I_W', 'DC_stream', 'AC_stream');
```

![image-20210701131710654](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210701131710654.png)

由此可见，编码生成成功。

### 10

在上一张图片中,double型的数据实际上是bit，而原始图片的数据为uint8型，因此压缩比为：
$$
\eta =\frac{120\times 168\times 8}{23072+2054}=6.41885
$$

### 11

- 解码DC部分：

```matlab
function DC_decode_array = DC_decode(DC_stream, DC)
    DC_decode_array = [];
    index = 1;
    [H, ~] = size(DC);
    while(index < length(DC_stream))

        % scan DC to fit Hufffman code
        for k = 1: H
            tmp_Huffman_length = DC(k, 1);
            tmp_Huffman = DC(k, 2: tmp_Huffman_length+1);
            if isequal(tmp_Huffman, DC_stream(index: index+tmp_Huffman_length-1))
                index = index + tmp_Huffman_length;
                break
            end
        end
        
        % get data
        if k == 1   % data = 0 should be considered exclusively
            tmp_data_de = 0;
            index = index + 1;
        else
            tmp_data_bi = DC_stream(index: index+k-2);
            if tmp_data_bi(1) == 0  % if data < 0, more operation is needed
                is_negative = 1;
            else
                is_negative = 0;
            end
            if is_negative
                tmp_data_bi = 1 - tmp_data_bi;
                tmp_data_de = -bi2de(flip(tmp_data_bi));
            else
                tmp_data_de = bi2de(flip(tmp_data_bi));
            end
            index = index + k - 1;
        end
        
        % put data into DC_decode_array
        if isempty(DC_decode_array) 
            DC_decode_array = [DC_decode_array, tmp_data_de];
        else
            tmp_data_de = DC_decode_array(end) - tmp_data_de;
            DC_decode_array = [DC_decode_array, tmp_data_de];
        end
    end
end
```

- 解码AC部分：

```matlab
function AC_decode_array = AC_decode(AC_stream, AC)
    AC_decode_array = [];
    index = 1;
    tmp_array = []; % store one block's AC code
    [H, ~] = size(AC);
    while index < length(AC_stream) 
        
        
        % Huffman decode
        flag = 1;   % deal with EOB condition
        for k = 1: H
            tmp_Huffman_length = AC(k, 3);
            tmp_Huffman = AC(k, 4: tmp_Huffman_length+3);
            tmp_index_end = index+tmp_Huffman_length-1;
            if tmp_index_end >= length(AC_stream)   % end of AC_stream: out of range!
                break;
            end
            if isequal(tmp_Huffman, AC_stream(index: tmp_index_end))
                index = index + tmp_Huffman_length;
                flag = 0;
                break
            end
        end

        % get run, size and data itself
        if flag % EOB condition or 16-zeros condition
            if isequal(AC_stream(index: index + 10), [1,1,1,1,1,1,1,1,0,0,1])
                % 16-zeros
                zeros_filled = zeros(1, 16);
                tmp_array = [tmp_array, zeros_filled];
                index = index + 11;
                continue;
            else
                % EOB
                zeros_filled = zeros(1, 63 - length(tmp_array));
                tmp_array = [tmp_array, zeros_filled];
                AC_decode_array = [AC_decode_array, tmp_array];
                tmp_array = [];
                index = index + 4;
                continue;
            end
        end
        tmp_run = AC(k, 1); % run
        tmp_size = AC(k, 2);    % size
        tmp_data_bi = AC_stream(index: index + tmp_size - 1);
        if tmp_data_bi(1) == 0
            tmp_data_bi = 1 - tmp_data_bi;
            tmp_data_de = -bi2de(flip(tmp_data_bi));
        else
            tmp_data_de = bi2de(flip(tmp_data_bi));
        end
        index = index + tmp_size;

        % update tmp_array
        tmp_array = [tmp_array, zeros(1, tmp_run), tmp_data_de];
    end
end

```

两部分解码之后，已经可以生成Z_q验证纯解码部分的正确性：

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_11_1.bmp" style="zoom: 80%;" />

由此可见，解码部分完全正确。

- 图像复原部分

```matlab
function I = recover(H, W, DC_decode_array, AC_decode_array, Q)
    I = zeros(H, W);
    step_range = W / 8;
    storage_index = [
        1,2,6,7,15,16,28,29,...
        3,5,8,14,17,27,30,43,...
        4,9,13,18,26,31,42,44,...
        10,12,19,25,32,41,45,54,...
        11,20,24,33,40,46,53,55,...
        21,23,34,39,47,52,56,61,...
        22,35,38,48,51,57,60,62,...
        36,37,49,50,58,59,63,64
    ];
    for k = 1: length(DC_decode_array)
        tmp_DC = DC_decode_array(k);
        tmp_AC = AC_decode_array(63 * (k-1) + 1: 63 * k);
        tmp_block = [tmp_DC, tmp_AC];
        tmp_block = tmp_block(storage_index);
        tmp_block = reshape(tmp_block, 8, 8);
        tmp_block = tmp_block';
        tmp_block = tmp_block .* Q;
        tmp_block = idct2(tmp_block);
        tmp_block = round(tmp_block + 128);
        w_index = mod(k - 1, step_range);
        h_index = floor((k - 1) / step_range);
        I(h_index * 8 + 1: (h_index + 1) * 8, w_index * 8 + 1: (w_index + 1) * 8) = tmp_block;
        
    end
    I = uint8(I);	# 一定要注意double到uint8的转换！！
end
```

- 顶层复原函数：

```matlab
function I = decode(filename, Q, DC, AC)
    % load necessary data
    data = load(filename);
    H = data.I_H;
    W = data.I_W;
    DC_stream = data.DC_stream;
    AC_stream = data.AC_stream;
    DC_decode_array = DC_decode(DC_stream, DC);
    AC_decode_array = AC_decode(AC_stream, AC);
    I = recover(H, W, DC_decode_array, AC_decode_array, Q);
end
```

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_11_2.bmp" style="zoom:80%;" />

由此可见，图像复原相当成功！

- 进一步，将9到11中的所有函数进行整合，可得集量化、编码、解码、还原于一体的函数$jpeg-transmission$ ，形式如下：

```matlab
function I_recoverd = jpeg_transmission(I, Q, DC, AC)
    Z_q = quantify(I, Q);
    [DC_stream, AC_stream] = encode(Z_q, DC, AC);
    [I_H, I_W] = size(I);
    save('jpegcodes.mat', 'I_H', 'I_W', 'DC_stream', 'AC_stream');
    I_recoverd = decode('jpegcodes.mat', Q, DC, AC);
end
```

- 采用PSNR客观评价压缩质量：

```matlab
I_recoverd = jpeg_transmission(I, Q, DC, AC);
delta = I_recoverd - I;
MSE = sum(sum(delta .* delta)) / (120 * 168);
PSNR = 10 * log10(255 ^ 2 / MSE);
disp(PSNR);
```

计算结果为$34.9dB$，可见，压缩质量相当好。

### 12

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_12.bmp" style="zoom: 80%;" />

Q总体缩减一半后，对视觉效果似乎并没有造成什么重大影响，虽然在理论上它应该会更加精确。

### 13

- “雪花”压缩前后对比：

<img src="E:\courses\matlab\图像处理大作业\image\jpeg_13.bmp" style="zoom:80%;" />

并没有看出什么明显的差别。

- 采用PSNR客观评价压缩质量，得到的结果为$32.18dB$，比测试图像的效果要差一些。个人认为，可能的原因是相比于测试图像，雪花图像中包含更多的高频分量，而这在量化时会被舍去，因而造成较大的损失。

## 信息隐藏练习题

信息隐藏中，我采用了与JPEG的DC编码中相似的编码格式来表示将要录入图片的信息。首先，为了方便获取和破解隐藏在图片中的信息，定义字符串与二进制Huffman码的转换函数：

- 字符串转Huffman码：

```matlab
function huff = info2huff(info, DC)
    huff = [];
    info_de = abs(info);
    for k = 1: length(info_de)
        tmp = info(k);
        tmp_binary = flip(de2bi(abs(tmp)));
        tmp_index = DC(length(tmp_binary) + 1, :);
        tmp_Huffman_length = tmp_index(1);
        tmp_Huffman = tmp_index(2: 1+tmp_Huffman_length);
        huff = [huff, tmp_Huffman, tmp_binary];
    end
    END_OF_HUFF = [1,1,1,1,1,1,1,1,1,1,0];	% 自定义的终止符，与DC编码中的Huffman码兼容
    huff = [huff, END_OF_HUFF];
end
```

- Huffman码转字符串：

```matlab
function info = huff2info(huff, DC)
    info = [];
    index = 1;
    [H, ~] = size(DC);
    while index < length(huff)

        flag = 1;
        % scan DC to fit Hufffman code
        for k = 1: H
            tmp_Huffman_length = DC(k, 1);
            tmp_Huffman = DC(k, 2: tmp_Huffman_length+1);
            if isequal(tmp_Huffman, huff(index: index+tmp_Huffman_length-1))
                index = index + tmp_Huffman_length;
                flag = 0;
                break
            end
        end

        % if no matched Huffman code, just terminate the decode
        if flag
            break;
        end

        % get data
        if k == 1   % data = 0 should be considered exclusively
            tmp_data_de = 0;
            index = index + 1;
        else
            tmp_data_bi = huff(index: index+k-2);
            tmp_data_de = bi2de(flip(tmp_data_bi));
            index = index + k - 1;
        end
        
        % put data into info
        info = [info, mod(tmp_data_de, 128)];	% 取余是为了防止解码过程中的乱码影响到了0-127的ASCII码值而产生报错。
        info = char(info);
    end
end
```

### 1

- 空域隐藏信息：

```matlab
function image_encrypt = encrypt_in_space(I, huff)
    image_encrypt = I;
    [~, W] = size(I);
    index = 1;
    while index < length(huff)
        flag = 1;
        if index + 64 > length(huff)
            block_huff = [huff(index: length(huff)), zeros(1, 63 - length(huff) + index)];
            flag = 0;
        else
            block_huff = huff(index: index + 63);
        end
        k = floor(index / 64);
        W_range = W / 8;
        a = floor(k / W_range);
        b = mod(k, W_range);
        block = I(a * 8 + 1: (a+1) * 8, b * 8 + 1: (b+1) * 8);
        image_encrypt(a * 8 + 1: (a+1) * 8, b * 8 + 1: (b+1) * 8) = block_encrypt_in_space(block, block_huff);
        if flag
            index = index + 64;
        else
            break;
        end
        % imshow(image_encrypt);
    end
end

function block_encrypt = block_encrypt_in_space(block, block_huff)	% 按块存储信息。
    block_encrypt = zeros(8, 8);
    for a = 1: 8
        for b = 1: 8
            point = block(a, b);
            point_code = block_huff((a-1) * 8 + b);
            block_encrypt(a, b) = 2 * floor(point / 2) + point_code;
        end
    end
    block_encrypt = uint8(block_encrypt);
end
```

其中隐藏时并不是普通的按列隐藏，而是按$8\times8$的块来存储信息，只不过在扫描块时仍是顺序扫描，亦即，一个块被填满了之后，才将Huffman码填到下一块。

- 空域解码信息：

```matlab
function huff = decrypt_in_space(I)
    [H, W] = size(I);
    huff = zeros(1, H*W);
    index = 1;
    while index < length(huff)
        k = floor(index / 64);
        W_range = W / 8;
        a = floor(k / W_range);
        b = mod(k, W_range);
        block = I(a * 8 + 1: (a+1) * 8, b * 8 + 1: (b+1) * 8);
        huff(index: index + 63) = block_decrypt_in_space(block);
        index = index + 64;
    end
end

function huff_decrypt = block_decrypt_in_space(block)
    huff_decrypt = zeros(1, 64);
    for a = 1: 8
        for b = 1: 8
            point = block(a, b);
            huff_decrypt(8 * (a-1) + b) = mod(point, 2);
        end
    end
end
```

- 倘若不经过JPEG压缩，设计代码，观察信息是否能还原：

```matlab
I_encrypt = encrypt_in_space(I, huff);
% I_recoverd = jpeg_transmission(I, Q, DC, AC);
huff_decrypt = decrypt_in_space(I_encrypt);
info_decrypt = huff2info(huff_decrypt, DC);
disp('after_decrypt:');
disp(info_decrypt);
```

![image-20210702114540123](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210702114540123.png)

发现确实能还原，说明信息隐藏与还原代码均正确。

- 经过JPEG压缩后，再次观察代码还原程度：

![image-20210702162137141](C:\Users\DELL\AppData\Roaming\Typora\typora-user-images\image-20210702162137141.png)

发现根本无法还原，说明空域隐藏信息在JPEG编码格式下不可用。

- 图像受损程度：

![](E:\courses\matlab\图像处理大作业\image\hide_space_1.bmp)

发现图像质量影响不大。

### 2

